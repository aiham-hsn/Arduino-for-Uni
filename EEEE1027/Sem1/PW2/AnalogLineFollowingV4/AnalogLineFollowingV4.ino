#include <LiquidCrystal.h>

// // Pin definitions
// Encoders
const int
  ENCODER_LEFT = A3,
  ENCODER_RIGHT = 2;

// IR Sensors
const int
  IR_LEFT = A4,
  IR_RIGHT = A5;

// Motor controls
const int
  ENA = 11,  // Enable right-side pair of motors -- Pair A
  ENB = 3,   // Enable left-side pair of motors -- Pair B
  IN1 = A1,  // Command Pair A forwards
  IN3 = 12,  // Command Pair A backwards
  IN2 = A2,  // Command Pair B forwards
  IN4 = 13;  //Command Pair B backwards

// ------------------------------------------------
// ------------------------------------------------

// // LCD
// LCD control pins
const int
  REGISTER_SELECT = 8,
  ENABLE = 9,
  DB4 = 4,
  DB5 = 5,
  DB6 = 6,
  DB7 = 7;
// Initialize the LCD
LiquidCrystal lcd(REGISTER_SELECT, ENABLE, DB4, DB5, DB6, DB7);

// ------------------------------------------------
// ------------------------------------------------

//// Distance & Time

// Variables for measuring distance traveled
// Minimum distance = 955 cm
// Maximum distance = 993 cm
float distance = 0.0;  // Calculated distance in centimeters
const float
  WHEEL_CIRCUM = 20.46,          // Circumference of the wheels of the line following car in centimeters
  PULSES_PER_REVOLUTION = 40.0;  // Number of pulses generated by the encoder wheel for one full revolution.
volatile int
  encLeft_highCount = 0,   // Count of '1's for ENCODER_LEFT
  encRight_highCount = 0;  // Count of '1's for ENCODER_RIGHT

// Time tracking variables
unsigned long startTime = 0;
volatile unsigned long elapsedTime = 0;
bool inMotion = false;

// Display distance function
void displayDistance() {
  // Print distance on the 2nd row of the LCD
  lcd.setCursor(0, 1);
  lcd.print("Dist: ");
  lcd.print(distance, 2);  // Print to 2 decimal places
  lcd.print(" cm   ");
}

// Display time function
void displayTime(volatile unsigned long time) {
  // Calculate time in seconds
  const unsigned long seconds = time / 1000;

  // Print time on the 1st row of the LCD
  lcd.setCursor(0, 0);
  lcd.print("Time: ");
  lcd.print(seconds);
  lcd.print("s     ");
}

//// Distance Calculations Interrupts
// Interrupt Service Routine (ISR) for ENCODER_LEFT
void encoderLeft_ISR() {
  encLeft_highCount++;  // Increase count of encoder highs if rising edge is detected
}
// Interrupt Service Routine (ISR) for ENCODER_RIGHT
void encoderRight_ISR() {
  encRight_highCount++;  // Increase count of encoder highs if rising edge is detected
}

// ------------------------------------------------
// ------------------------------------------------

//// Line following
// Speeds
const int
  mainSpeed = 80,   // main speed of the LFC (Line Following Car)
  highSpeed = 255,  // higher speed of the LFC
  lowSpeed = 0;     // lower speed of the LFC

const int IR_THRESHOLD = 200;  // Threshold for line detection

// Movement functions
void moveForward() {
  // Speed control
  analogWrite(ENA, mainSpeed);
  analogWrite(ENB, mainSpeed);
  // Direction control
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);

  if (inMotion == false) { inMotion = true; }
}
void moveLeft() {
  // Speed control
  analogWrite(ENA, highSpeed);
  analogWrite(ENB, highSpeed);
  // Direction control
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, HIGH);

  if (inMotion == false) { inMotion = true; }
}
void moveRight() {
  // Speed control
  analogWrite(ENA, highSpeed);
  analogWrite(ENB, highSpeed);
  // Direction control
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN4, LOW);

  if (inMotion == false) { inMotion = true; }
}
void moveStop() {
  // Speed control
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // Direction control
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);

  if (inMotion == true) { inMotion = false; }
}

// ------------------------------------------------
// ------------------------------------------------

void setup() {
  // Set up Encoder Pin as inputs
  pinMode(ENCODER_LEFT, INPUT);
  pinMode(ENCODER_RIGHT, INPUT);

  // Set up IR sensor pins as inputs
  pinMode(IR_LEFT, INPUT);
  pinMode(IR_RIGHT, INPUT);

  // Set up motor pins as outputs
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN4, OUTPUT);

  // Attach interrupt to the encoder pins on the rising edge
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), encoderLeft_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), encoderRight_ISR, RISING);

  // Initialize the LCD
  lcd.begin(16, 2);  // Set up the LCD with 16 columns and 2 rows
  lcd.print("Starting run...");

  delay(600);   // Wait a little before starting to move
  lcd.clear();  // Clear LCD

  // Set Starting time of run
  startTime = millis();
}

void loop() {
  // Read IR sensor values
  int leftSensor = analogRead(IR_LEFT);
  int rightSensor = analogRead(IR_RIGHT);

  //// Line-following logic
  // Neither sensor is seeing the line, move straight
  if (leftSensor > IR_THRESHOLD && rightSensor > IR_THRESHOLD) {
    moveForward();
  }
  // Left sensor is seeing the line, turn left
  if (leftSensor < IR_THRESHOLD && rightSensor > IR_THRESHOLD) {
    moveLeft();
  }
  // Right sensor is seeing the line, turn right
  if (leftSensor > IR_THRESHOLD && rightSensor < IR_THRESHOLD) {
    moveRight();
  }
  // Both sensors are seeing the line, stop
  if (leftSensor < IR_THRESHOLD && rightSensor < IR_THRESHOLD) {
    moveStop();
  }

  if (inMotion == true) {
    // Calculate the amount of time that has passed
    elapsedTime = millis() - startTime;

    // Calculate distance
    float encoderAverage = ((float)(encLeft_highCount + encRight_highCount)) / 2.0;
    distance = ((float)encoderAverage / PULSES_PER_REVOLUTION) * WHEEL_CIRCUM;  // distance is in centimeters

    // Print distance & time
    displayTime(elapsedTime);
    displayDistance();
  }

  delay(30);  // Adjust the delay for smoother updates
}
