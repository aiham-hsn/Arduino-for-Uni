#include <util/atomic.h>

//// Pin definitions
// Encoders
const int
  ENCODER_LEFT = 2,
  ENCODER_RIGHT = 3;

// Motor controls
const int
  ENA = 5,   // Enable right-side pair of motors -- Pair A
  ENB = 6,   // Enable left-side pair of motors -- Pair B
  IN1 = 4,   // Command Pair A forwards
  IN3 = A0,  // Command Pair A backwards
  IN2 = 7,   // Command Pair B forwards
  IN4 = A2;  // Command Pair B backwards

// ------------------------------------------------
// ------------------------------------------------

float
  encoderAverage = 0.0,  // Calculated distance in centimeters
  distance = 0.0,  // Calculated distance in centimeters
  currDistTravelled = 0.0;
const float
  // WHEEL_CIRCUM = 20.46,          // Circumference of the wheels of the line following car in centimeters
  // WHEEL_CIRCUM = 32.736,          // Circumference of the wheels of the line following car in centimeters
  // WHEEL_CIRCUM = 8.184,          // Circumference of the wheels of the line following car in centimeters
  WHEEL_CIRCUM = 12.276,         // Circumference of the wheels of the line following car in centimeters
  PULSES_PER_REVOLUTION = 80.0;  // Number of pulses generated by the encoder wheel for one full revolution.
volatile int
  encLeft_highCount = 0,  // Count of '1's for ENCODER_LEFT
  encLeft_highCountStore = 0,
  encRight_highCount = 0,  // Count of '1's for ENCODER_RIGHT
  encRight_highCountStore = 0;

// Time tracking variables
unsigned long
  startTime = 0,
  elapsedTime = 0;

//// Distance Calculations Interrupts
// Interrupt Service Routine (ISR) for ENCODER_LEFT
void encoderLeft_ISR() {
  encLeft_highCount++;  // Increase count of encoder highs if rising edge is detected
}
// Interrupt Service Routine (ISR) for ENCODER_RIGHT
void encoderRight_ISR() {
  encRight_highCount++;  // Increase count of encoder highs if rising edge is detected
}

void moveForward(int speed) {
  // Speed control
  analogWrite(ENA, speed);
  analogWrite(ENB, speed);
  // Direction control
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);
}
void moveStop() {
  // Speed control
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  // Direction control
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);
}

const int DURATION = 2000;

void setup() {
  // Set up Encoder Pin as inputs
  pinMode(ENCODER_LEFT, INPUT);
  pinMode(ENCODER_RIGHT, INPUT);

  // Attach interrupt to the encoder pins on the rising edge
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), encoderLeft_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), encoderRight_ISR, RISING);

  // Start Serial Comms
  Serial.begin(115200);
  // Clear lines to indicate new serial data
  Serial.println("");
  Serial.println("");

  delay(500);  // Delay for a bit to show the "MPU6050 Found" message

  startTime = millis();
}

void loop() {
  elapsedTime = millis() - startTime;

  // Disable interrupts when using the encoder high counts to do math
  // From https://docs.arduino.cc/language-reference/en/variables/variable-scope-qualifiers/volatile/#example-code
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    // Calculate distance
    encoderAverage = ((float)(encLeft_highCount + encRight_highCount)) / 2.0;
    distance = ((float)encoderAverage / PULSES_PER_REVOLUTION) * WHEEL_CIRCUM;  // distance is in centimeters
    // distance = ((float)encLeft_highCount / PULSES_PER_REVOLUTION) * WHEEL_CIRCUM;  // distance is in centimeters
  }

  if (elapsedTime <= DURATION) {
    moveForward(127);
  } else {
    moveStop();
  }

  Serial.print(elapsedTime);
  Serial.print(",");
  Serial.print(encLeft_highCount);
  Serial.print(",");
  Serial.print(encRight_highCount);
  Serial.print(",");
  Serial.print(distance);
  Serial.println("");

  delay(10);
}
