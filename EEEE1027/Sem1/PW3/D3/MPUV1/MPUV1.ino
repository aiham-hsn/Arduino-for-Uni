#include <string.h>
#include <LiquidCrystal.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

const int LOOP_DELAY = 20;

// Pin definitions
// Encoders
const int
  ENCODER_LEFT = A2,
  ENCODER_RIGHT = A1;

// IR Sensors
const int
  IR_LEFT = A3,
  IR_RIGHT = A0;

// Motor controls
const int
  ENA = 5,  // Enable right-side pair of motors -- Pair A
  ENB = 6,  // Enable left-side pair of motors -- Pair B
  IN1 = 4,  // Command Pair A forwards
  IN3 = 2,  // Command Pair A backwards
  IN2 = 7,  // Command Pair B forwards
  IN4 = 3;  //Command Pair B backwards

// LCD control pins
const int
  REGISTER_SELECT = 12,
  ENABLE = 13,
  DB4 = 8,
  DB5 = 9,
  DB6 = 10,
  DB7 = 11;
// Initialize the LCD
LiquidCrystal lcd(REGISTER_SELECT, ENABLE, DB4, DB5, DB6, DB7);

// Distance & Time
float distance = 0.0;  // Calculated distance in centimeters
const float
  WHEEL_CIRCUM = 20.46,          // Circumference of the wheels of the line following car in centimeters
  PULSES_PER_REVOLUTION = 40.0;  // Number of pulses generated by the encoder wheel for one full revolution.
volatile int
  encLeft_highCount = 0,   // Count of '1's for ENCODER_LEFT
  encRight_highCount = 0;  // Count of '1's for ENCODER_RIGHT

unsigned long startTime = 0;
unsigned long elapsedTime = 0;
bool inMotion = false;

//Distance tracking variables
bool hasMoved80cm = false;
unsigned long stopTime = 0;

// Display distance function
void displayDistance() {
  lcd.setCursor(0, 1);
  lcd.print("Dist: ");
  lcd.print(distance, 2);
  lcd.print(" cm   ");
}

// Display time function
void displayTime(volatile unsigned long time) {
  const unsigned long seconds = time / 1000;

  lcd.setCursor(0, 0);
  lcd.print("Time: ");
  lcd.print(seconds);
  lcd.print("s     ");
}

// Interrupt Service Routine (ISR) for ENCODER_LEFT
void encoderLeft_ISR() {
  encLeft_highCount++;
}

// Interrupt Service Routine (ISR) for ENCODER_RIGHT
void encoderRight_ISR() {
  encRight_highCount++;
}

// Line following logic
const int MAIN_SPD = 80, HI_SPD = 255, LO_SPD = 0;
const int IR_THRESHOLD = 200;

void moveForward(int speed) {
  analogWrite(ENA, speed);
  analogWrite(ENB, speed);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);

  if (inMotion == false) { inMotion = true; }
}

void moveLeft() {
  analogWrite(ENA, HI_SPD);
  analogWrite(ENB, HI_SPD);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, HIGH);

  if (inMotion == false) { inMotion = true; }
}

void moveRight(int speed) {
  analogWrite(ENA, speed);
  analogWrite(ENB, speed);
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN4, LOW);

  if (inMotion == false) { inMotion = true; }
}

void moveStop() {
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);
  digitalWrite(IN1, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN4, LOW);

  if (inMotion == true) { inMotion = false; }
}

void lineFollowingLogic(int normalSpeed, int leftSensor, int rightSensor) {
  if (leftSensor > IR_THRESHOLD && rightSensor > IR_THRESHOLD) {
    moveForward(normalSpeed);
  } else if (leftSensor < IR_THRESHOLD && rightSensor > IR_THRESHOLD) {
    moveLeft();
  } else if (leftSensor > IR_THRESHOLD && rightSensor < IR_THRESHOLD) {
    moveRight(HI_SPD);
  } else if (leftSensor < IR_THRESHOLD && rightSensor < IR_THRESHOLD) {
    moveStop();
  }
}

// MPU-6050 Accelerometer
float accel_x, accel_y, accel_z;
double roll = 0, pitch = 0, maxPitch = 0;

char messageSer[15] = "";
char message[15] = "";
char angle[10] = "";

Adafruit_MPU6050 mpu;

float calcPitch(const float x, const float y, const float z) {
  double x_Buff = (double)x;
  double y_Buff = (double)y;
  double z_Buff = (double)z;
  double rad2deg = (double)180 / (double)PI;
  float result = atan2((-x_Buff), sqrt(y_Buff * y_Buff + z_Buff * z_Buff)) * rad2deg;

  return result;
}

void displayAngle(const float angle, const float max) {
  lcd.setCursor(0, 0);
  lcd.print("Angle: ");
  lcd.print(angle, 2);
  lcd.print("DEG  ");

  lcd.setCursor(0, 1);
  lcd.print("Max: ");
  lcd.print(max, 2);
  lcd.print("DEG  ");
}

bool reachedTop = false, topWaitEnd = false, hasSpun = false;
const int Z_COMP_WAIT_INTVL = 500;
unsigned long reachedTopTime, turnStartTime;
unsigned long REACH_TOP_DURATION = 2360;
unsigned long TOP_WAIT_DURATION = 4000;
unsigned long TURN_DURATION = 2480;

float prevZAccel = 0;
int zAccelSameCnt = 0;

// 360-degree turn function
void turn360Degrees() {
  encLeft_highCount = 0; // Reset encoder count
  encRight_highCount = 0;

  moveLeft(); // Start turning left
  while (encLeft_highCount < PULSES_PER_REVOLUTION) {
    // Wait for the left encoder to complete one full revolution
  }
  moveStop(); // Stop motors after completing the turn
}


void setup() {
  pinMode(ENCODER_LEFT, INPUT);
  pinMode(ENCODER_RIGHT, INPUT);
  pinMode(IR_LEFT, INPUT);
  pinMode(IR_RIGHT, INPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN4, OUTPUT);

  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), encoderLeft_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), encoderRight_ISR, RISING);

  lcd.begin(16, 2);
  lcd.setCursor(0, 0);
  lcd.print("Looking for MPU");
  delay(400);

  Serial.begin(115200);
  Serial.println("");

  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MPU6050 Found");
  lcd.print("MPU6050 Found");
  mpu.setAccelerometerRange(MPU6050_RANGE_16_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_10_HZ);

  delay(500);
  lcd.print("Starting run...");
  delay(500);
  lcd.clear();
  startTime = millis();
}

void loop() {
  elapsedTime = millis() - startTime;
  int leftSensor = analogRead(IR_LEFT);
  int rightSensor = analogRead(IR_RIGHT);

  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  accel_x = a.acceleration.x;
  accel_y = a.acceleration.y;
  accel_z = a.acceleration.z;

  pitch = calcPitch(accel_x, accel_y, accel_z);
  maxPitch = max(maxPitch, pitch);

  float encoderAverage = ((float)(encLeft_highCount + encRight_highCount)) / 2.0;
  distance = ((float)encoderAverage / PULSES_PER_REVOLUTION) * WHEEL_CIRCUM;

  if (reachedTop == false && topWaitEnd == false && hasSpun == false && elapsedTime <= REACH_TOP_DURATION) {
    moveForward(255);
    displayAngle(pitch, maxPitch);
  }

  if (reachedTop == false && topWaitEnd == false && hasSpun == false && elapsedTime > REACH_TOP_DURATION) {
    reachedTopTime = elapsedTime;
    reachedTop = true;
  }

  if (reachedTop == true && topWaitEnd == false && (elapsedTime - reachedTopTime) <= TOP_WAIT_DURATION && hasSpun == false) {
    moveStop();
    displayAngle(pitch, maxPitch);
  }

  if (reachedTop == true && topWaitEnd == false && (elapsedTime - reachedTopTime) > TOP_WAIT_DURATION && hasSpun == false) {
    turnStartTime = elapsedTime;
    topWaitEnd = true;
  }

  // Execute 360-degree turn
  if (reachedTop == true && topWaitEnd == true && hasSpun == false) {
    turn360Degrees(); // Perform the turn
    hasSpun = true;   // Mark the turn as completed
  }

  if (reachedTop == true && topWaitEnd == true && hasSpun == true && !hasMoved80cm) {
    if (abs(pitch) < 3) {  // Check if the car is on a flat surface
      if (distance < 80.0) {
        lineFollowingLogic(MAIN_SPD, leftSensor, rightSensor);  // Follow the line
        displayDistance();  // Display the distance
        displayTime(elapsedTime);  // Display time
      } else {
        moveStop();  // Stop the car after moving 80 cm
        hasMoved80cm = true;  // Mark that the car has moved 80 cm
        stopTime = millis();  // Record the stop time
        lcd.clear();  // Clear the LCD
        lcd.setCursor(0, 0);
        lcd.print("Stopped for 3s");
        delay(3000);  // Pause for 3 seconds
        lcd.clear();  // Clear the LCD again
      }
    } else {
      lineFollowingLogic(MAIN_SPD, leftSensor, rightSensor);  // Follow the line if not flat
    }
  } else {
    // After moving 80 cm, continue following the line and display distance and time
    if (hasMoved80cm) {
      lineFollowingLogic(MAIN_SPD, leftSensor, rightSensor);  // Follow the line
      displayDistance();  // Display the distance
      displayTime(elapsedTime);  // Display time
    }
  }

  // Add a delay between each iteration of the loop to prevent overloading the system
  delay(LOOP_DELAY);  // Wait for a short period before running the next iteration of the loop
}
